// run code with: FreeFem++ polya.edp
//general explination http://www.cmap.polytechnique.fr/~beniamin.bogosel/faber_krahn_polygons.html


//returns a vector of random numbers between 0 and 1
func real[int] rand(int h){
  real[int] vec(h);
  for(int i = 0;i<h;i++){
     vec(i) = randreal1();
  }
  return vec;
}

//    ns - numSides
//    das - deltaAngleScale
func real[int] calculateAngles(int ns, real das){
      real[int] deltaAngle = rand(ns);                // entries b/w 0 and 1 to scale angle shift
      real[int] angles = 1:ns;                        // fill with 1,2,3,...,numSides

      // Sets the angles to regular angles then shifts them by deltaAngle
      angles = 2*pi/ns*angles;                        // cuts 2pi into numSides equal pieces
      angles = angles+das*deltaAngle;                 // deforms it into a non-regular by shifting the angle by deltaAngle

      return angles;
}

func int calculateCoords(real[int] &xx, real[int] &yy, real[int] angles, real[int] radii){
      xx = cos(angles);
      yy = sin(angles);
      return 0;
}

//CONSTANTS

//polygon
int numSides = 5;
int numEigenvalues = 0;
real deltaAngleScale = 0.5;                           // changes how different the polygon is from regular
real[int] xx(numSides);                               // x value for each vertex
real[int] yy(numSides);                               // y value for each vertex
real[int] radii(numSides);                            // distance from center to a given vertex
real[int] angles(numSides);

//runtime
verbosity = 0;                                        // global variable in FreeFem that determines how much output it prints (from 0 to 3)
real stepSize  = 0.1;

// approximiation
int[int] numMeshCells(numSides);  
numMeshCells = 20;

// calculate polygon data
angles = calculateAngles(numSides, deltaAngleScale);
calculateCoords(xx, yy, angles, radii);

//real[int] xx = [0, 0.2,  0.5,   1  ,1.1, 2,  2,  1.2,0];
//real[int] yy = [0,-0.7, -0.9,  -0.8,0  ,0.3,1  ,1.5,1];


int[int] ind1 = 0:1:numSides-1;
int[int] ind2 = ind1;
int[int] ind3 = ind1;
ind2(1:numSides-1) = 0:1:numSides-2;
ind2(0) = numSides-1;
ind3(numSides-1) = 0;
ind3(0:numSides-2) = 1:numSides-1;

real alpha = 0.001;
real minv = 100000;
int count = 1;


while(alpha>1e-10){


border poly(t=0,1; i){
    x=(1-t)*xx[i]+t*xx[ind3(i)]; 
    y=(1-t)*yy[i]+t*yy[ind3(i)];
    label=i;
}


mesh Th = buildmesh (poly(numMeshCells));

// shows Mesh, slows down the steps a lot
//Th= adaptmesh(Th,1./50,IsMetric=1);
//plot(Th);


// Th - the mesh
// P1 - piecewise linear continuous finite element (2d, 3d, surface 3d), the degrees of freedom are the vertices values
// Vh - the finite element space
fespace Vh(Th,P1);

// variables(FE-functions) on the mesh
Vh u1,u2;

int[int] BC = 0:1:numSides-1;       // label indexes for each disk
                                    // used for the boundary condition

// Define the problem in weak form
varf a(u1,u2) = int2d(Th)
(dx(u1)*dx(u2) + dy(u1)*dy(u2))+on(1,u1=0)//on(C1,C2,C3,C4,u1=1)
                               +on(BC,u1=0);     
varf b([u1],[u2]) = int2d(Th)(  u1*u2 ) ; 

// define matrices for the eigenvalue problem
matrix A= a(Vh,Vh,solver=Crout,factorize=1); 
matrix B= b(Vh,Vh,solver=CG,eps=1e-20); 

// we are interested only in the first eigenvalue
int eigCount = numEigenvalues+1;
real[int] eigenValue(eigCount); // Holds eigenvalues
Vh[int] eigenFunction(eigCount);   // holds eigenfunctions
// Solve Ax=lBx
int numEigs = EigenValue(A,B,sym=true,sigma=0,value=eigenValue,vector=eigenFunction);

// make all of the eigenfunctions positive
if(int2d(Th)(eigenFunction[numEigenvalues])<0){
  eigenFunction[numEigenvalues] = -eigenFunction[numEigenvalues];
}

real[int] derx(numSides);
real[int] dery(numSides);
real[int] ax(numSides);
real[int] ay(numSides);
mesh Eh = emptymesh(Th);
fespace Wh(Eh,P1);
real l1,l2;

Wh av,ap;
real val1,val2;  
Vh ff = 1;
real ar = int2d(Th)(ff);
real[int] diffs(numSides);
real[int] dots(numSides);

for(int i=0;i<numSides;i++){
l1 = sqrt((xx[i]-xx[ind3(i)])^2+(yy[i]-yy[ind3(i)])^2);
l2 = sqrt((xx[i]-xx[ind2(i)])^2+(yy[i]-yy[ind2(i)])^2);
diffs[i] = abs(l1-l2);
dots[i] = (xx[i]-xx[ind3(i)])*(xx[i]-xx[ind2(i)])+
          (yy[i]-yy[ind3(i)])*(yy[i]-yy[ind2(i)]);
//cout << ind2(i) << " " << ind3(i) << endl;
//cout  <<  l1 << "  " << l2 << endl;

av = (l2- (sqrt((xx[i]-x)^2+(yy[i]-y)^2)))/l2;
//plot(av,fill=true,value=true);
 
ap = (l1 - (sqrt((xx[i]-x)^2+(yy[i]-y)^2)))/l1;
//plot(ap,fill=true,value=true);
 
//val1 = int1d(Th,i)(ap);
//cout << "Integral " << val1 << endl;
//val2 = int1d(Th,ind2(i))(av);
//cout << "Integral " << val2 << endl;

derx[i] = -int1d(Th,i)(ap*(dx(eigenFunction[numEigenvalues])*N.x+dy(eigenFunction[numEigenvalues])*N.y)^2*N.x)-
      int1d(Th,ind2(i))(av*(dx(eigenFunction[numEigenvalues])*N.x+dy(eigenFunction[numEigenvalues])*N.y)^2*N.x);

dery[i] = -int1d(Th,i)(ap*(dx(eigenFunction[numEigenvalues])*N.x+dy(eigenFunction[numEigenvalues])*N.y)^2*N.y)-
      int1d(Th,ind2(i))(av*(dx(eigenFunction[numEigenvalues])*N.x+dy(eigenFunction[numEigenvalues])*N.y)^2*N.y);

ax[i] = int1d(Th,i)(ap*N.x)+
      int1d(Th,ind2(i))(av*N.x);

ay[i] = int1d(Th,i)(ap*N.y)+
      int1d(Th,ind2(i))(av*N.y);

}
real maxdif = diffs.max;
real amax   = dots.max;
real amin   = dots.min;

derx = derx+ax;
dery = dery+ay;
real[int] integrals(numSides);
//for(int i=0;i<numSides;i++)
//integrals[i] = int1d(Th,i)((dx(eigenFunction[numEigenvalues])*N.x+dy(eigenFunction[numEigenvalues])*N.y)^2);
//cout << "Integrals " << integrals << endl;

xx = xx-stepSize*derx;
yy = yy-stepSize*dery;

// decrease step size as time goes on
if(count%200 == 0){
stepSize = stepSize/10;
}

count++;
plot(eigenFunction[numEigenvalues],fill=true,ShowAxes = 0);
cout << count << " " << eigenValue[0]+ar << " " << stepSize << " " << maxdif << 
" " << amax-amin << endl;
if(count>1000)
break;
}

